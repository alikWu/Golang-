# GOROOT与GOPATH
GOROOT： Go语言的安装路径。
也就是说GOROOT存放的Golang语言的内建程序库的所在位置，通常安装完成后，电脑就会设置好GOROOT路径，当你开发Golang程序，import内建的程序库的时候，
并不需要额外安装、下载，当程序运行后，也会先去GOROOT路径下寻找相对应的程序库来运行。

GOPATH：我们自己定义的工作空间，可以包含若干工作区目录的路径（eg：export GOPATH=/usr/local/projects:/home/alik/go), 每个目录都代表Go语言的一个工作区（workspace）。

# go构建模式的前世今生
Go 程序由 Go 包组合而成的，Go 程序的构建过程就是确定包版本、编译包以及将编译后得到的目标文件链接在一起的过程。
Go 语言的构建模式历经了三个迭代和演化过程，分别是最初期的 GOPATH、1.5 版本的 Vendor 机制，以及现在的 Go Module。

## GOPATH
Go 语言在首次开源时，就内置了一种名为 GOPATH 的构建模式。在这种构建模式下，Go 编译器可以在本地 GOPATH 环境变量配置的路径下，搜寻 Go 程序依赖的第三方包。如果存在，就使用这个本地包进行编译；如果**不存在**，就会报编译错误。
这也意味着你得提前手动使用go get将各个依赖包下载到本地GOPATH中。


### Go 编译器在 GOPATH 构建模式下，究竟怎么在 GOPATH 配置的路径下搜寻第三方依赖包呢?
先假定 Go 程序导入了 github.com/user/repo 这个包，我们也同时假定当前 GOPATH 环境变量配置的值为：
```shell
export GOPATH=/usr/local/projects:/home/alik/go
```
那么在GOPATH 构建模式下，Go 编译器在编译 Go 程序时，就会在下面两个路径下搜索第三方依赖包是否存在：
```shell
/usr/local/projects/src/github.com/user/repo
/home/alik/go/src/github.com/user/repo
```
如果你没有显式设置 GOPATH 环境变量，Go 会将 GOPATH 设置为默认值，不同操作系统下默认值的路径不同，在 macOS 或 Linux 上，它的默认值是 $HOME/go。


### 如何解决没有在本地找到程序的第三方依赖包的问题
可以通过 **go get** 命令将本地缺失的第三方依赖包下载到本地，比如：
```shell
go get github.com/sirupsen/logrus
```
go get 命令，不仅能将 logrus 包下载到 GOPATH 环境变量配置的目录下，它还会检查 logrus 的依赖包在本地是否存在，如果不存在，go get 也会一并将它们下载到本地。

不过，go get 下载的包只是那个时刻各个依赖包的**最新主线版本**，这样会给后续 Go 程序的构建带来一些问题。比如，依赖包持续演进，可能会导致不同开发者在不同时间获取和编译同一个 Go 包时，
得到不同的结果，也就是不能保证可重现的构建（Reproduceable Build）。又比如，如果依赖包引入了不兼容代码，程序将无法通过编译。
如果依赖包因引入新代码而无法正常通过编译，并且该依赖包的作者又没用及时修复这个问题，这种错误也会传导到你的程序，导致你的程序无法通过编译。

    也就是说，**在 GOPATH 构建模式下，Go 编译器实质上并没有关注 Go 项目所依赖的第三方包的版本**。但 Go 开发者希望自己的 Go 项目所依赖的第三方包版本能受到自己的控制，而不是随意变化。
于是 Go 核心开发团队引入了 Vendor 机制试图解决上面的问题。

## vendor
    Go 在 1.5 版本中引入 vendor 机制。vendor 机制本质上就是在 Go 项目的某个特定目录下，将项目的所有依赖包缓存起来，这个特定目录名就是 vendor。























# Reference
https://time.geekbang.org/column/article/429941?utm_campaign=geektime_search&utm_content=geektime_search&utm_medium=geektime_search&utm_source=geektime_search&utm_term=geektime_search

