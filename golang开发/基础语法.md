# 命令源码文件
命令源码文件是程序的运行入口，是每个可独立运行的程序必须拥有的。我们可以通过构建或安装，生成与其对应的可执行文件，后者一般会与该命令源码文件的直接父目录同名。

如果一个源码文件声明属于main包，并且包含一个无参数声明且无结果声明的main函数，那么它就是命令源码文件。
### flag
flag包被用来接收运行参数，
```go
var name string
flag.StringVar(&name,"name","everyone","The greeeting object")
flag.Parse()
```
flag.Parse()必须在flag.String等函数调用之后，在读取任何命令参数值之前。
# 库源码文件
库源码文件是不能被直接运行的源码文件，它仅用于存放程序实体。
同一个目录下的源码文件都需要被声明为属于同一个代码包。
程序实体的访问权限分为：包级私有、公开、以及模块级私有(internal)。internal代码包中声明的公开程序实体仅能被该代码包的直接父包及其子包中的代码引用
# 程序实体
程序实体变量包括：变量、常量、函数、结构体和接口。
声明变量的方式有：
```go
var name string
```
和
```go
name :=     短变量声明，只能在函数体内部使用
```
### 类型转换
T(x)，x可以是一个变量，也可以是一个代表值得字面量，还可以是一个表达式。

### 变量类型判断
1. 类型断言：x.(T)
    ```go
    value, ok := interface{}(a).([]string)
    ```
2. swith语句
    ```go
    switch x.(type) {
    case TypeA: ......
    case TypeB: ......
    }
    ```
### 潜在类型
```go
type MyString string
```
stirng是MyString的潜在类型。潜在类型的含义是某个类型在本质上是哪个类型。潜在类型相同的不同类型的值之间是可以进行类型转换的。另外，即使两个类型的潜在类型相同，他们的值之间也不能进行判等或比较，它们的变量之间也不能赋值。
### 别名类型
```go
type MyString = string
```
顾名思义，别名类型与其源类型的区别只在名称上，他们是完全相同的

# 数组与切片
数组类型的值的长度是固定的，而切片类型的值是可变长的。切片底层数据结构中一定包含一个数组。golang中的引用类型有：切片、字典、通道、函数。

在切片和数组之上都可以应用切片表达式，得到一个新的切片，eg: s[3:6]。

len(s):得到s的长度， 数组的长度与容量是一样的。

cap(s):得到s的容量, 切片的容量实际上代表了它的底层数组的长度.

一旦一个切片无法容纳更多的元素，就会扩容。但它并不会改变原来的切片，而是会生成一个容量更大的切片，然后将原有的元素和新元素一并拷贝至新切片.

往切片s中追加新元素a,b，长度必然改变;在无需扩容时，append函数返回的是指向原底层数组的新切片；在需要扩容时，append函数返回的是指向新底层数组的新切片。
一般情况下，新切片的容量将会是原切片容量的2倍。但在原切片的长度大于或等于1024是，会以原容量的1.25倍作为心容量的基准；若一次追加的元素过多，以至于使新长度比容量的2倍还大，则以新长度为新容量基准。

*copy([a []int, b []int)* 只支持切片，把切片中的数据复制到a中相应的位置。如果两个切片的长度不一样的，就会按其中较小的那个切片的元素个数进行复制

# 字典
字典本质上就是一个哈希表， 在一个nil字典上不能添加键值对（只声明，没初始化的字典）。字典的键类型不能是函数类型、字典类型和切片类型。若键的类型是接口类型，那么键值的实际类型也不能是这三种类型，数组元素也不能是这三种类型。键类型的值之间必须可以施加==。

delete函数
```go
b := map[string]string{"France":"Paris","Italy":"Rome","Japan":"Tokyo"}
delete(b,"France")
```
# 通道channel
通道类型是并发安全的，这是golang自带的、唯一一个可满足并发安全性的类型。通道类型在初始化之前，也为nil。通道类型的变量可以用来传递值。通道类型并没有对应的值表示法，值具有即时性，无法用字面量准确表达。
虽然说通道类型是并发安全的，但是因为“向通道发送值的操作”会受到“关闭操作”的影响，所以得加锁，用来判断通道是否关闭。如果不关闭通道，根本无需在进行发送操作时使用锁。

容量为0的channel叫非缓冲通道。
若有多个goroutine因向一个已满的channel发送元素值而被阻塞，那么当该通道中有多余空间的时候，最早被阻塞的那么G会最先被唤醒；对接收操作也是如此。

发送方向通道发送的值会被复制，接收方接收的总是该值的副本。经由通道传递的值至少会被复制一次，至多两次。当向一个已空的通道发送值，且已有至少一个接收方因此等待时，该通道会绕过本身的缓冲队列，直接把值复制给最早等待的那个接收方。

无论怎样都不应该在接收端关闭通道。试图向一个已关闭的通道发送元素值，会引起panic；关闭一个已关闭的通道也会引起panic。
通道在被关闭时仍有元素值，依然可以用接收表达式取出，并根据该表达式的第二个结果值判断通道是否已关闭且已无元素可取。

len(ch)查询channel内部的数据长度 //可用于已关闭的channel

cap(ch)查询channel的容量

### 单向通道
```go
chan<- int
<-chan int
```
单向通道不应该出现在变量的声明中，否则就没有意义。 
单向通道用于函数/方法参数或结果列表声明中，用于约束对该通道的操作。单向通道都是由双向通道转换而来的，能且只能由函数/方法参数或结果列表声明转换。

### for range
该循环一直接收channel ch中的数据，直到ch关闭
```go
for e := range ch{
    ......
}
```
### select case
select是专为channel设计的语法，它和switch语句接近。分支上可以有多个case块和最多一个default块。所有的case语句要么是channel的发送操作，要么是channel的接收操作。

如果有多个case可以运行，select会随机选择一个执行，其它不会执行；
如果没有可以运行的case，且有default语句，那么会执行default动作；
如果没有可以运行的case，且没有default语句，select将堵塞，知道某个case通信可以运行；
```go
select {
    case <- ch1:
         ......
    case ch2 <- data:
         ......
}
```
# 结构体
struct{}{},占用的内存空间是0字节，在整个golang程序中都只会存在一份。
### 字符表示
可以通过为一个类型编写名为String的方法，来自定义该类型的字符表示形式
```go
func (ac Animal) String() string{
    ......
}
```
### 方法
方法隶属的类型不局限于结构体类型，但必须是某个自定义的数据类型，且不能是任何接口类型。一个数据类型关联的所有方法共同组成了该类型的方法集合。同一个方法集合中的方法不能重名。并且，他们的名称与该类型中任何字段的名称也不能重复。

*值方法与指针方法*

值方法的接收者是所属类型值的一个副本。在该方法内对该副本的修改一般都不会体现在原值上，除非这个类型本身是某个引用类型（比如切片）的别名类型。指针方法的接收者是那个类型值的指针值的一个副本，会体现在原值上。
一个自定义数据类型的方法集合中仅会包含它的所有值方法，而该类型的指针类型的方法集合却包括了值方法和指针方法。

严格来讲，我们在某个数据类型的值上只能调用它的值方法。但golang会适时地为我们进行自动地转译，使得我们在值上也能调用它的指针方法。eg:cat.SetName("monster") , 假设SetName不是cat的值方法，而是它的指针方法， 则golang会把它转译为(&cat).SetName("monster")

### 匿名字段（嵌入字段）
某个字段只有类型名，该字段就叫匿名字段。嵌入字段的方法集合会被无条件地合并进被嵌入类型的方法集合中。只要名称相同，无论这两个方法的签名是否一致，被嵌入类型的方法会屏蔽嵌入字段的。类似的，嵌入字段的方法也会被相同字段“屏蔽”。但可以通过链式的选择表达式选择到嵌入字段的字段或方法。普通字段的方法不属于该结构体的方法

golang无继承。只是通过嵌入字段的方式实现了类型间的组合。

### 面向对象编程
将属性及其能力（或者说数据及其操作）封装在一起，是面向对象编程的一个主要原则。从这方面看，golang其实是支持面向对象编程的。

# 接口
接口类型与其它数据类型不同，它是没法值化的，或者说没法被实例化。如果没有任何数据类型可以作为它的实现，那么该接口的值就不可以存在。

一个数据类型实现了某个接口类型中的某个方法，必有：
1. 两个方法的签名完全一致，返回值类型也要一致
2. 两个方法的名称要一致
一个函数实现了某个函数类型，必有：签名完全一致，返回值类型也要一致。


接口类型本身是无法值化的，在赋予它实际的值之前，它的值一定是nil。不过要注意，即使我们像前面的例子那样把dog的值赋给了pet，pet的值与dog的值也是不同。

当我们给一个接口变量赋值时，该变量的动态类型会与它的动态值一起被存储在一个专用的数据结构（iface）中。所以，*一个接口变量的值其实是iface的一个实例*。iface包含两个指针：一个指向类型信息的指针和一个指向动态值的指针。

类型断言： interface{}(a).(int)

# 函数
golang中函数是一等公民，函数类型也是一等的数据类型。 对于函数类型来说，它是一种对一组输入、输出进行模板化的重要工具，它的值也借此变成了可以被热替换的逻辑组件。

函数可以有名字，也可以没有名字。方法却必须有名字，不能被当成值来看待，隶属于某类型。
### 闭包
在一个函数中存在对外来标识符的引用， 闭包的意义在于动态地生成部分程序逻辑

# 指针
&dog的结果就是指针值，还有其它几样东西可以表示“指针”，最贴近传统意义的是uintptr(内建数据类型）。unsafe.Pointer也代表了“指针”。可表示任何指向可寻址的值的指针，也是前面说的指针值与uintptr之间的桥梁。

uintptr是一个整数类型，可以进行算术运算，unsafe.Pointer是一个指针类型。
```go
dogP := &dog
dogPtr := uintptr(unsafe.Pointer(dogP))
namePtr := dogPtr + unsafe.Offsetof(dogP.name)
nameP := (*string)(unsafe.Pointer(namePtr))  //nameP是指向dog的name字段的指针值
//*nameP即为name字段的值了。
*nameP = "monster" //修改dog的name字段的值（非安全方式）
```
常量的值是不可寻址的
# switch
### 表达式switch
```go
switch 1 {
    case 0：
        ......
    case 1:
        ......
}
```
switch 中的表达式是可选的，可以省略。如果省略表达式，则相当于 switch true，这种情况下会将每一个 case 的表达式的求值结果与 true 做比较，如果相等，则执行相应的代码。
```go
switch {
    case num>1:
        ......
    case false:
       .......
}
```
fallthrough既是一个关键字，又可以代表一条语句。fallthrough语句可被包含在表达式switch语句中的case语句中。它的作用是使控制权流转到下一个case。不过要注意，fallthrough语句仅能作为case语句中的最后一条语句出现。并且，包含它的case语句不能是其所属switch语句的最后一条case语句。不能用于类型switch

### 类型switch
```go
switch t := v.(type) {
    case uint8:
        ......
    case string:
        ......
}
```

# iota
iota在const关键字出现时将被重置为0, 下面例子中的a,b都为0
```go
const a = iota
const b = iota
```
const中每新增一行常量声明将使iota计数一次，即+1
```go
const (
   a =  iota
   b = iota
)
```
跳值使用法
```go
const (
    a = iota
    b = iota
    _
    c = iota
)//a为0，b为1，c为3
```
插队使用法
```go
const (
     a = iota
     b = 3.14
     c = iota 
) //a为0，b为3.14，c为2
```
表达式隐式使用法
```go
const (
    a = iota * 2
    b
    c
) //a为0，b为2，c为4
当没有给b iota的时候，它会隐式的继承前一个非空表达式，相当于const (
a = iota * 2
b = iota * 2
c = iota * 2
)
```
单行使用法
```go
const (
   a, b = iota, iota + 3
   c, d
   f = iota
)//a=0，b=3 , c = 1, d = 4 ,f = 2
```
# unicode
rune是内建数据类型, 一个值代表一个字符，存储一个UTF-8编码值，长度可变，有[1,4]字节，如一个中文字符需三个字节
```go
type rune = int32
```
一个string类型值由若干个Unicode字符组成，每个Unicode字符都可以用一个rune类型的值来承载。

golang不但拥有可以独立代表Unicode字符的类型rune，还有可以对字符串值进行Unicode字符拆分的for语句：
```go
str := "Go爱好者"
for i, c := range str {
    fmt.Printf("%d: %q [%x] \n", i,c,[]byte(string(c)))
}//i表示第几个字节，c表示字符
```
输出为：
```shell
0: ‘G' [47]
1: 'O' [6f]
2: '爱' [e7 88 b1]
5: '好' [e5 a5 bd]
8: '者' [e8 80 85]
```

# 错误处理
error类型是一个接口类型，也是一个golang内建类型。在这个接口类型中只包含了一个方法Error，这个方法不接受参数，但会返回一个string类型的结果。

构造错误体系方法：
1. error是根，net.Error接口是一个在根上延伸的第一级非叶子节点。这个当拿到一个错误值的时候，可以先判断是否为net.Error，然后继续往下查找。
2. net、os包中的一些错误类型，都有一个名为Err，类型为error的字段，代表的也是当前错误的潜在错误（就是当前错误的上一级错误）。
# panic
运行时异常（恐慌）。 内建函数panic专门用于引发panic，参数可以是任意类型，但一般是error或string类型。

与从函数返回错误值的意义是完全不同的。当我们的函数返回一个非nil的错误值时，函数的调用方有权不处理，且不处理的后果是不致命的。而panic不施加保护措施则是致命的。

内建函数recover专用于恢复panic， recover得与defer联用，才可恢复panic。

# 测试
一般来说，一个测试源码文件只会针对某个命令源码文件，或库源码文件做测试。分为： 功能测试， 基准测试（也称为性能测试）， 示例测试（example）（示例测试严格来讲也是一种功能测试，只不过它更关注程序打印出的内容。）

测试源码文件的主名称应以被测源码文件的主名称为前导，并必须以"_test"为后缀。
每个测试源码文件都必须至少包含一个测试函数：
1. 功能测试函数:名称必须以Test为前缀，且唯一参数的类型*testing.T
2. 性能测试函数: 名称必须以Benchmark为前缀，且唯一参数的类型为*testing.B
3. 示例测试函数: 名称必须以Example为前缀，但对参数列表无规定

go test 包: 用于功能测试。

go test -bench=.  -run=^$ 包： 第一个标记-bench=. 表示执行包中任意名称的性能测试函数（当然也得符合golang规则）；第二个标记-run=^$ 表示执行名称为空的功能测试函数，即不执行功能测试。













