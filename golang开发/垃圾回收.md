# GC是什么？

      当一个电脑上的动态内存不再需要时，就应该予以释放，以让出内存，这种内存资源管理，称为垃圾回收，简称GC。 

      GC是编程语言中提供的自动内存管理机制，自动释放不需要的内存对象，让出存储器资源，它在一定程度上解决了内存管理的问题，有效的防止内存泄漏，有效的使用空闲的内存。

      GC过程中无需程序手动执行，GC机制在现代很多编程语言中都支持，GC能力的性能与优劣也是不同语言之间对比度指标之一。

### 什么是内存泄漏？

         内存泄漏，是从操作系统的角度来阐述的，形象的比喻就是“操作系统可提供给所有进程的存储空间（虚拟内存空间）正在被某个进程榨干”，导致的原因就是程序在运行的时候，会不断地动态开辟存储空间，这些存储空间在运行结束之后并没有及时释放掉。

        应用程序在分配了某段内存之后，由于设计的错误，会导致程序失去了对该段内存的控制，而对应的程序又没有很好的GC机制去对程序申请的空间进行回收，这样就造成了内存空间的浪费，从而导致内存泄漏。

# GC的原理

任何一种垃圾回收算法一般要做两件基本事情：

- 找到无用的对象
- 回收无用对象占用的内存空间，使该空间可被程序再次使用

内存管理的基本流程如下：

          等待回收 → 找到回收对象 → 回收 → 释放

## 触发GC的阈值（回收时机）

Go触发GC运行的调用方式：

- 阈值（分配内存时调用）：默认内存扩大一倍，启动gc   位置：runtime/malloc.go:mallogc()
- 定时调用：默认2min触发一次gc，位置：src/runtime/proc.go:forcegcperiod
- 手动调用：runtime/mgc.go:GC()

## 怎么找到无用的对象？

### 1.引用计数法

        给每个对象添加一个引用计数器，如果被引用则计数器+1， 如果引用该对象的对象被销毁则计数器-1， 当计数器为0时，代表该对象没有被引用就需要回收了。

       但如果两个对象互相引用，比如A引用了B，B又引用了A，那就无法释放了。

**优点：**

       高效，引用计数收集器可以很快的被回收，不会出现内存耗尽或达到某个阈值时才回收，**对程序需要不被长时间打断的实时环境比较有利。（ 运行期没有停顿，即实时性：对象一旦没有引用，将直接被释放。实时性还带来一个好处是：处理回收内存的时间分摊到了平时）**

**缺点：**

       不能检测出循环引用，而且实时维护引用计数，也有一定的代价。

**代表语言： Python、PHP、Swift**。 Python中主要采用引用计数机制为主，标记-清除和分代回收机制为辅的策略。

### 2.根搜索算法

       可达性分析设立若干种根对象，根对象的字对象也是存活的，当任何一个根对象到某一个对象都无法可达时，那么这个对象就是可回收的。

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/bfcc6768-ccea-4378-9937-5d1739e243de/Untitled.png)

如上图右侧白色部分则为根无法到达，从根变量开始遍历所有引用的对象，引用的对象标记为“被引用”，没有被标记的会被判断为垃圾进行回收。

       在Go语言汇总，可以当作GC roots的对象有以下几种：

- 全局变量
- 各个G stack上的变量等

**优点：**

       解决了循环引用的问题

**缺点：**

       需要STW，STW是gc的最大性能问题，对于gc而言，需要暂时停掉程序运行，也就是暂时停止程序的所有的内存变化，即停止所有goroutine，等待gc结束之后才恢复。

**代表语言：Golang（采用三色标记法）（早期Go中GC的STW停顿实践甚至达到了s级，对时间敏感的实时通信等应用程序会造成巨大的影响）**

## 常见的GC算法

### 1.复制算法

        简单的说就是： 把空间里的活动对象复制到其他空间，把原空间里的所有对象都回收掉。

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/c5d0a34a-43f8-42dc-8c11-2fbbcdbb80f0/Untitled.png)

        复制算法将内存划分为两个区间，在任意时间点，所有动态分配的对象都只能分配在其中一个区间（称为活动区间），而另外一个区间（称为空闲区间）则是空闲的。
        当有效内存空间耗尽时，虚拟机将暂停程序运行，开启复制算法GC线程，接下来GC线程会将活动区间内的存活对象，全部复制到空闲区间，且**严格按照内存地址依次排序**，与此同时，GC线程将更新存活对象的内存引用地址指向新的内存地址。

       复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，必须要克服50%内存的浪费。具体流程如下：

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/7e1113bd-c342-4c29-b433-14eb6065f07d/Untitled.png)

        当From空间被占满时， GC将活动的对象全部复制到To空间，当复制完成后，该算法会将From空间和To空间互换，GC结束，**From空间和To空间大小必须一致**，这是为了保证能把From空间中的所有活动对象都复制到To空间里

**优点：**

       优秀的吞吐量，可实现高速分配，不会发生碎片化

**缺点：**

        需要把堆进行二等分，只有一半的堆能被使用，造成堆的浪费。 STW，程序出现卡顿

### 2.标记-清除算法

        标记-清除算法采用从根集合进行扫描，对存活的对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收。

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/dd62348d-c1a3-458e-af83-16e2271b1320/Untitled.png)

      标记-清除算法不需要进行对象的移动，并且**仅对不存活的对象进行处理**，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。

      标记-清除算法可以有标记阶段和清除阶段构成，标记阶段是把所有活动对象都坐上标记的阶段，清除阶段是把那么没有标记的对象，也就是非活动对象回收的阶段，通过这两个阶段，就可以令不能利用的内存空间重新得到利用。

**标记阶段**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/d2804da2-3dd1-4425-9f4d-cda3a1d8a004/Untitled.png)



![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/c735c267-4269-4c11-8a6b-2d502a16b8f8/Untitled.png)

进行标记通常采用的搜对对象算法为：**深度优先搜索**，深度优先搜索比广度优先搜索更能压低内存使用量，因此在标记阶段经常用到深度优先搜索。

在进行标记的时候，GC只会收集各个对象的标志位并表格化，不会根对象一起管理，不在对象的头里置位，而是在这个表格中的特定场所置位，像这样集合了用于标记的位的表格称为“位图表格”，利用这个表格进行标记的行为称为“位图标记”。

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/a5978cfd-325e-4a8b-bdb9-d09380ab9bef/Untitled.png)

**清除阶段**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/e2bfc35c-02df-40ca-ba60-e55396fde135/Untitled.png)

        在清除阶需要回收内存，使其能再次利用：把垃圾对象（回收内存）链接到空闲的链表，搜索空闲链表并寻找大小合适的分块，然后进行合并操作：在分配的时候有不同的分配策略，根据分配策略的不同可能会产生大量的小分块，如果它们是连续的，就能把所有的小分块连在一起形成大分块，这种“连接连续分块”的操作叫做合并，合并是在清除阶段进行的。

**延迟清除法**

       清除操作所花费的时间与堆大小成正比的，如果处理的堆越大，清除算法所花费的时间就越长。

        延迟清除法，在标记操作结束后，不一定会进行清除操作（而是在结束STP后），这样能缩短STP的暂停时间。

**优点：**

     标记-清除算法实现简单，与其他的算法组合也就相对简单，使用了“根搜索算法”找到无用的对象

**缺点：**

      不会移动对象，容易产生碎片化的空间，造成内存浪费。 STW，程序出现卡顿

**代表语言：Golang（三色标记法）**

### 3.标记-整理算法

       分为标记阶段和压缩阶段， 标记阶段采用和上面的标记-清除算法一样的方式进行对象的标记，但在压缩整理时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动并整理到一起，并更新对应的指针。

       标记-整理算法实际上是在标记-清除算法的基础上，又进行了对象的移动，因此**成本更高，但是解决了内存碎片的问题。**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/1b0894aa-2891-4ea7-97f4-ab12dd22fbf4/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/e89a0c7d-b33d-4258-8efa-3c8380562631/Untitled.png)

**优缺点：**

        可有效利用堆，但是压缩会有计算成本

### 4. Generation算法（分代回收算法）

**原理：**

        不同的对象的生命周期是不一样的，因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率与效果。

**过程：**

        **按照对象生命周期长短不同，将堆分为新生代和老年代**，生命周期长的放入老年代，而短的放入新生代，根据区域特点选用不同的收集算法，如果新生代朝生夕死，则采用复制算法，老年代采用标记-清除，或标记-整理。

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/b1aca7d9-d11d-4836-b7de-eac3a15c6f85/Untitled.png)

**扩展：**

每次使用Eden和一块Survivor，回收时，将存活的对象一次性复制到另一块Survivor上，如果另一块Survivor空间不足，则使用分配担保机制进入老年代，什么时候从Survivor进入老年代，视垃圾回收器类型而定

**优点：**

        回收性能好

**缺点：**

        算法复杂。 STW，程序出现卡顿

**代表语言：JAVA**

# Go的GC机制

### 演变过程

- Go V1.1: STW
- Go V1.3: 标记-清除法
- Go V1.5:三色并发标记法
- Go V1.8:混合写屏障机制（hybrid write barrier）

go的gc采用了**并发**标记-清除算法的三色标记法，并做了一定改进，大部分的工作时在标记垃圾，基本原理是根据“根搜索算法”的根可达性分析，减少了STW的时间。

## Go V1.3及之前的标记-清除算法

**具体步骤：**

- 第一步：**暂停程序业务逻辑**，分类出可达和不可达的对象，然后做上标记
- 第二步：开始标记，程序找出它所有可达的对象，并做上标记
- 第三步：标记完之后，开始清除未标记的对象
- 第四步：**停止暂停**，让程序继续跑，然后循环重复这个过程，直到程序生命周期结束

**缺点：**

1. STW，程序出现卡顿
2. 比较需要扫描整个heap（堆）
3. 清除数据会产生heap碎片

       Go V1.3版本之前就是以上来实施的，在执行GC的基本流程就是首先启动STW暂停，然后执行标记，最回收，最后停止STW，如下图所示：

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/cc77f8c1-7e39-4a29-8dae-e1750c61add2/Untitled.png)

这样全部的GC时间都是包裹在STW范围内的，这样程序暂停的时间过长，影响程序的运行性能，所以Go V1.3 做了简单的优化，将STW的步骤提前，减少STW暂停的时间范围，如下图所示：

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/ab71325a-3ca0-49e2-bdc5-9b0dc4e59d2f/Untitled.png)

因为在清除的时候，这些对象已经是不可达了，不会出现回收写冲突的问题，这就是前面说的**延迟清除法。**

        但无论怎么优化，Go V1.3都面临着这样一个重要问题：就是mark-and-sweep算法会**暂停整个程序。**

## Go V1.5的三色并发标记法

       三色标记法是传统的标记-清除算法的一个改进，它是一个**并发**的GC算法，GC过程和其他gouroutine并发运行，其实大部分的工作还是在标记垃圾。

       基本原理基于根可达（根搜索算法），但需要一定时间的STW，所以GC的过程实际上就是通过**四个阶段的标记**来确定清除的对象都有哪些。

### 三种颜色介绍

       三色标记法将对象的颜色分为白、灰、黑三种颜色：

- 白色：该对象没有被标识过（垃圾对象）
- 灰色：该对象已经被标记过了，但该对象下的属性没有全被标记完（程序需要的对象，GC需要从此对象中继续遍历标记）
- 黑色：该对象已经被标记过了，且该对象下的属性也全部都被标记过了（程序所需要的对象）

### GC的四个阶段

1. **Mark Prepare-STW**: 做标记阶段的准备工作，需要停止所有正在运行的goroutine，即STW，**标记根对象，启用内存屏障**，**内存屏障有点像内存读写钩子**，它用于在后续并发标记的过程中，维护三色标记的完备性（三色不变形），这个过程通常很快，大概在10～30us
2. **Marking-Concurrent**: 标记阶段会将大概25%的P用于标记对象，逐个扫描所有G的堆栈，执行三色标记，在这个过程中，**所有新分配的对象都是黑色**，**被扫描的G会被暂停，扫描完成后恢复**，这部分工作叫后台标记，这会降低系统大概25%的吞吐量。同时，为了防止Marking过程中，其他G分配堆内存太快，导致Mark跟不上Allocate的速度，还需要其它G配合做一部分标记的工作，这部分工作叫辅助标记（mutator assists）：在Marking期间，每次G分配内存都会更新它的“负债指数”，分配得越快，“负债指数”越大，这个指数乘以全局的“负载汇率”，就得到这个G需要帮忙Marking的内存大小，也就是它在本次分配的辅助标记的工作量。
3. **Mark Termination- STW**： 标记阶段的最后工作是Mark Termination，**关闭内存屏障，停止后台标记以及辅助标记**，做一些清理工作，整个过程需要STW，大概需要60～90us。
4. **Sweeping - Concurrent**：在标记工作完成之后，剩下的就是清理过程了，清理过程的本质是将没有被使用的内存块整理回收给上一个内存管理层级，清理回收的开销被平摊到应用程序的每次内存分配操作中，知道所有内存都Sweeping完成。

**在Marking-Concurrent阶段，有三个问题：**

1. GC协程和业务协程是并行运行的，大概会占用25%的CPU，使得程序的吞吐量下降
2. 如果业务协程分配堆内存太快，导致Mark跟不上Allocate的速度，那么业务协程会被招募去做协助标记，暂停对业务逻辑的执行，这回影响到服务处理请求的耗时。
3. Go GC在稳态场景下可以很好的工作，但是在瞬态场景下，如定时的缓存失效，定时的流量脉冲，GC影响会急剧上升。

        在**Marking-Concurrent和Mark Termination- STW阶段，**这两个阶段虽然按照官方的说法时间会很短，但是在实际的线上服务中，有时会在trace图中观测到长达十几ms的停顿，原因可能为：OS线程在做内存申请的时候触发内存整理被“卡住”，Go runtime无法抢占处于这种情况的goroutine，进而阻塞STW完成。

### GC流程

第一步：每次新创建的对象，默认的颜色都是标记为“白色”，如下图：

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/ec8bc671-c0c0-4aa7-a224-dd88cc22b610/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/0fab5bd5-774b-4419-a1e4-683e38037f8f/Untitled.png)

第二步：每次GC回收开始，会从根节点开始遍历所有对象，把遍历的对象从白色集合放入“灰色”集合，如下图所示：

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/5edc4d0e-71de-441a-860c-45dd2913af10/Untitled.png)

第三步：遍历灰色集合，将灰色集合引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合，如下图所示：

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/4e0f4058-1c60-40a5-a65f-daf3cf495b18/Untitled.png)

第四步：重复第三步，直到灰色中无任何对象，如图所示：

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/d3d69dce-8846-4fe7-9069-8aed2620a25f/Untitled.png)

第五步：回收所有的白色标记表的对象，也就是回收垃圾，如图所示：

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/702e2fcb-a6c7-4574-992f-6f2b6e139fc9/Untitled.png)

### 三色标记法存在的问题

**1.多标-浮动垃圾问题**

       假设E已经被标记了（变成灰色了），此时D和E断开了引用，按理来说对象E/F/G应该被回收的，但因为E已经变为灰色了，其仍会被当作存活对象继续遍历下去，最终的结果是：本轮GC不会回收这部分内存。这部分本应该回收但是没有回收到的内存，被称为“浮动垃圾”。

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/969fff7d-2591-4e58-8566-9a98f5b5224d/Untitled.png)

**2.漏标-悬挂指针问题**

       当GC线程已经遍历到E变成灰色，D变成黑色时，灰色E断开与白色G的引用，黑色D引用了白色G，此时切回GC线程继续跑，因为E已经没有对G的引用了，所以不会将G放到灰色集合。尽管D重新引用了G，但因为D已经是黑色了，不会再重新做遍历处理。

       最终的结果是：G会一致停留在白色集合中，最后被当作垃圾进行清除。这直接**影响到了应用程序的正确性**，这也是Go**需要在GC时解决**的问题。

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/2d503e9e-6619-48b3-842a-d4f990642ac8/Untitled.png)

### 屏障机制

        为了解决三色标记法中存在的问题，引入**屏障技术（内存屏障）**来保障数据的一致性。内存屏障能使CPU或编译器对在该屏障指令之前和之后发生的内存操作强制执行排序约束，在内存屏障前执行的操作一定会先于内存屏障后执行的操作。

       根据操作类型的不同，可以将内存屏障分成Read barrier（读屏障）和Write barrier（写屏障）两种，在Go中都是使用的写屏障。（对于一个不需要对象拷贝的垃圾回收器来说，读屏障的代价是很高的，因为对于这类垃圾回收器来说是不需要保存读操作的版本指针问题。相对来说，写屏障代价更小，因为堆中的写操作远远小于堆中的读操作。）

第一次STW会准备根对象的扫描，启动写屏障（Write Barrier）和辅助GC（mutator assist）。

第二次STW会重新扫描部分根对象，禁用写屏障和辅助GC。

**写屏障是如何实现的？**

       屏障技术是不在栈上应用的，因为要**保证栈的运行效率**。屏障机制是基于一个强-弱三色不变式来解决的。

**1.强-弱三色不变式**

强三色不变式：黑色对象不能引用白色对象。这样就不会出现有白色对象被误删的情况。

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/0cb18e3a-29b3-42df-8c78-1f3029124458/Untitled.png)

弱三色不变式：所有被黑色对象引用的白色对象都处于灰色保护

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/07fa20fa-54cd-4590-9062-c4cd36de8e9a/Untitled.png)

        弱三色不变式强调，黑色对象可以引用白色对象，但是这个白色对象必须存在其它灰色对象对它的引用，或者可达它的链路上有存在灰色对象。这样可以保护白色对象，使其安全。

为了遵循上述这两个方式，Golang团队初步得到了如下的两种写屏障方式：“插入屏障”，“删除屏障”。

**2.插入屏障**

       插入屏障只对堆上的内存分配起作用。（以当前对象或者说引用对象是否在堆中作为判断，从下面伪代码也能看出）

具体操作：在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)

满足：强三色不变式 （不存在黑色对象引用白色对象的情况了，因为白色会强制变成灰色）

插入屏障伪代码如下：

```go
添加下游对象(当前下游对象slot, 新下游对象ptr) {   
  //1
  标记灰色(新下游对象ptr)   
  
  //2
  当前下游对象slot = 新下游对象ptr  				  
}
```

场景：



```go
A.添加下游对象(nil, B)   //A 之前没有下游， 新添加一个下游对象B， B被标记为灰色
A.添加下游对象(C, B)     //A 将下游对象C 更换为B，  B被标记为灰色
```

       栈空间的特点是容量小,但是要求相应速度快,因为函数调用弹出频繁使用, 所以“插入屏障”机制,在**栈空间的对象操作中不使用**. 而仅仅使用在堆空间对象的操作中.

在A对象引用B对象的时候，B对象被标记为灰色（将B挂在A下游，B必须被标记为灰色），遵循三色不变式（不存在黑色对象引用白色对象的情况了，因为白色会强制变为灰色），但有一个不足之处：结束时需要**STW**来**重新扫描栈**，大约需要10～100ms。流程如下图：

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/8c5967fe-d41b-470b-a2d2-39d97108c0f0/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/33c76dce-37df-406c-be72-bc5fffc693b6/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/3827503b-f2fe-4e8e-97f5-77003a127fd4/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/37fa876e-0482-4c21-8e16-e2869b0b6699/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/4e09d76c-50bd-4786-b66a-db8e1be78fc0/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/6adb6377-4435-45f1-8cc3-1ebb3ec535fa/Untitled.png)

        但是因为**栈没有插入写屏障**，当全部三色标记扫描之后，栈上有可能依然存在白色对象被引用的情况（如上图中的对象9）。所以要对**栈**重新进行**三色标记扫描**，但这次为了对象不丢失，要对本次标记扫描启动STW暂停，直到栈空间的三色标记结束。

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/7c7f14fd-259f-4287-b453-640a9d5ebca2/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/fbfaa29a-cfd2-42fe-bbd3-d0b342280b4c/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/7cfe776d-c999-4619-bee7-99ffafa8931a/Untitled.png)

最后将栈和堆空间 扫描剩余的全部 白色节点清除. 这次STW大约的时间在10~100ms间.

**3.删除屏障**

具体操作：被删除的对象，如果自身为灰色或者白色，那么被标记为灰色

满足：弱三色不变式（保护灰色对象到白色对象的路径不会断）

伪代码：

```go
添加下游对象(当前下游对象slot， 新下游对象ptr) {
  //1
  if (当前下游对象slot是灰色 || 当前下游对象slot是白色) {
  		标记灰色(当前下游对象slot)     //slot为被删除对象， 标记为灰色
  }
  
  //2
  当前下游对象slot = 新下游对象ptr
}
```

场景：

```go
A.添加下游对象(B, nil)   //A对象，删除B对象的引用。  B被A删除，被标记为灰(如果B之前为白)
A.添加下游对象(B, C)		 //A对象，更换下游B变成C。   B被A删除，被标记为灰(如果B之前为白)
```

        删除屏障适用于**栈和堆**，在删除屏障机制下删除一个节点的引用时该节点会被置成灰色，后续会继续扫描该灰色对象的字对象.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/263d31eb-4f87-42ab-b359-dc9aeac6f55f/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/4939b920-23aa-492a-ac4d-f3a0906ae67f/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/e00c025a-fbf1-45da-9f4d-54c75ea9116a/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/5cd29835-7c18-447c-b690-27d5432d4954/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/f336c71e-9b48-4594-88d2-f9927705eb2f/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/9c15d2c5-fb31-4688-a467-2d968a89aab9/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/f2dafcbc-2e96-4552-844f-f63ff5d55e3f/Untitled.png)

       该方法就是**精准度不够高**，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉被删除的对象。

## Go v1.8混合写屏障机制

混合写屏障机制目的是解决上面v1.5屏障机制（插入（写）屏障和删除（写）屏障）的短板：

- 插入（写）屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活
- 删除（写）屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。

Go v1.8引入了混合写屏障机制，避免了对栈re-scan的过程，极大的减少了STW的时间，结合了两者的优点。

### 混合写屏障规则

具体操作：

1. GC开始时将栈上的所有对象（可达对象）全部扫描并标记为黑色（之后不在进行第二次重复扫描，且无需STW）
2. GC期间，任何在**栈上创建的新对象**，均为**黑色**。即使逃逸到堆上，也是黑色
3. 被删除的对象（引用被删除）标记为灰色。（仅应用于堆）
4. 被添加的对象（引用被添加）标记为灰色。（仅应用于堆）

满足：变形的弱三色不变式

伪代码：

```go
添加下游对象(当前下游对象slot, 新下游对象ptr) {
  	//1 
		标记灰色(当前下游对象slot)    //只要当前下游对象被移走，就标记灰色
  	
  	//2 
  	标记灰色(新下游对象ptr)
  		
  	//3
  	当前下游对象slot = 新下游对象ptr
}
```

屏障技术是**不在栈上应用**的，因为要**保证栈的运行效率**。

### 具体场景分析

       混合写屏障是GC的一种屏障机制，所以只是当程序执行GC的时候，才会触发这种机制。

**GC开始：扫描栈区，将可达对象全部标记为黑。**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/a5e4266c-2433-42a7-b4a4-d753a19c1f7e/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/86298087-2cfe-44d6-b65d-b62fcd925f13/Untitled.png)

**场景一：对象被一个堆对象删除引用，成为另一个栈对象的下游**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/b5a5e715-a1af-4304-a071-4bb1b6f1b9e8/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/b1f9382b-27a5-40fe-ba28-fb0445554e4d/Untitled.png)

**场景二：对象被一个栈对象删除引用，成为另一个栈对象的下游**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/c49cfea7-ba48-45af-818a-e1fd8bb537dd/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/9a1d530d-2784-49f5-8c21-65dd49f148ab/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/0ffe2c26-768b-4246-ad3a-97efcb23ce1a/Untitled.png)

扩展：如果对象9引用对象5，栈上没有写屏障，对象5最终还是白色的，这样不会造成误删吗？

答：这种情况是不会出现的，因为对象9看不见对象5，是不可达的，如果对象5时可达对象就不会变成白色了。白色表示已经断链了，是引用不到的，否则在STW期间，就不会被标记为白色了。

**场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/2dfb27b8-c366-40de-9f2a-fa0aae03ff1d/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/bc2d13a1-00ec-4534-af05-ee426f83b107/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/498324b3-9481-4584-9346-cbedabad4fff/Untitled.png)

**场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/cf685f74-d542-4bc5-92bc-c7e4fb7723f8/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/f05cda67-26db-4797-8172-c30856d458cc/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/d8bf5c7b-64c8-4f48-82d6-3b56c4e97c40/Untitled.png)

         Golang中的混合写屏障满足`弱三色不变式`，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。

# GC总结

以上便是Golang的GC全部的标记-清除逻辑及场景演示全过程。

GoV1.3- 普通标记清除法，整体过程需要启动STW，效率极低。

GoV1.5- 三色标记法， **堆空间启动写屏障，栈空间不启动**，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通 （详情见《golang混合写屏障详解）

GoV1.8-三色标记法，**混合写屏障机制， 栈空间不启动，堆空间启动**。整个过程几乎不需要STW，效率较高。

# GC性能评价标准

- 吞吐量
- 最大暂停时间
- 堆使用效率
- 访问的局部性

# Q&A

### Go GC回收栈内存吗？

不回收栈内存，GC只回收堆内存。因为栈上的局部变量在函数调用结束时会被自动销毁，因此它们不需要被垃圾回收器管理。

### 为什么GC不负责回收栈中的内存？

栈是一块专用内存，专门为了函数执行而准备的，存储着函数中的局部变量以及调用栈。除此之外，栈中的数据都有一个特点-简单。比如局部变量不能被函数外访问，所以这块内存用完就可以直接释放。正是因为这个特点，栈中的内存可以通过简单的编译器指令自动清理，不需要通过GC来回收。（其实就是编译的时候就知道什么时候该栈内存可以回收，直接添加回收指令就可以了）

### Go GC竟然不回收栈内存，为啥要标记栈内存为黑色？

因为栈内存可能引用了堆内存的对象，因此给先遍历栈对象，将其标记为黑色（引用的对象也就遍历了），方便后续遍历标记堆中的对象。

将栈上对象标记为黑色，可以避免在垃圾回收的标记阶段对这些对象进行重复扫描，提高垃圾回收的效率，减少垃圾回收器的工作量，优化性能。

**GC 刚开始的时候，会将栈上的可达对象全部标记为黑色，标记引用的堆对象为灰色**：在标记栈局部变量为黑色的同时，垃圾回收器会将这些局部变量引用的堆对象标记为灰色，并将它们加入到待处理队列中，以便在后续的并发标记阶段处理。

### 为什么不把标记清除放在一起呢？

既然找到了需要free的内存，为什么不直接清除掉，还要分两个环节来做呢？因为标记需要进行全局扫描，当gc扫描到一个内存，没有被使用时，但是此时很有可能存在一个未被扫描到的指针指向了内存，如果直接free掉就会造成“悬空指针”，影响后续运行，所以必须分为两个阶段，先全局扫描，进行标记，然后陆续进行“清除”

### **根对象都有哪些？怎么标记的？**

GC开始的时候，除了栈局部变量，垃圾回收器还会标记其他根对象（如全局变量和寄存器中的变量）为灰色，并将它们加入到待处理队列中。

- 全局变量：遍历所有全局变量和静态变量，将它们标记为灰色。
- 寄存器中的变量：遍历当前 CPU 寄存器中的变量，将它们标记为灰色。

标记其他根对象（如全局变量和寄存器中的变量）为灰色，而不是像栈局部变量那样标记为黑色，是为了更高效地处理对象引用，确保垃圾回收过程的准确性和效率。

灰色对象需要进一步处理。