# GC原理
https://alikwu.notion.site/Go-GC-c81399ef04134f688ccc97c107a17a34

# 详解golang混合写屏障
# 目标

篇文章目标是弄明白混合写屏障到底是怎么来的，解决什么问题，插入写屏障，删除写屏障 的特点分别是什么？

首先明白一个前提，**栈上，寄存器对象的赋值（插入，删除）不能 hook** ，这个因为考虑到性能损耗和实现复杂度。（ golang 从来没有在栈上使用写屏障，一直都是在堆上的插入写屏障，个人以为也是这个原因）

写屏障就是在赋值代码中，添加一段 hook 代码，这段 hook 代码就是所谓的屏障代码，由编译器在编译期生成。

        虽然插入写屏障能解决问题，但是 golang 针对栈上对象的赋值却没有捕捉（没有生成写屏障），原因自然是性能损耗和实现复杂度的考虑。这就开了一个例外的口子，有一些黑色的栈对象指向了白色的对象，而回收器却无法感知到。golang 的解决发放是：最后再 STW 重新扫描一把栈。这个自然就会导致整个进程的赋值器卡顿，所以后面 golang 是引用混合写屏障解决这个问题。

## 插入写屏障

1. 如果是纯粹的插入写屏障是满足强三色不变式的（永远不会出现黑色对象指向白色对象）；

2.但是由于栈上对象无写屏障（不 hook），那么导致黑色的栈可能指向白色的堆对象，所以必须假定赋值器（mutator）是灰色赋值器，扫描结束之后，必须 STW 重新扫描栈才能确保不丢对象；

1. STW 重新扫描栈再 goroutine 量大且活跃的场景，延迟不可控，经验值平均 10-100ms；

golang 1.5 之后实现的就是这种类型的插入写屏障。

# **混合写屏障**

golang 1.5 之后已经实现了插入写屏障，但是由于栈对象赋值无法 hook 的原因，导致扫描完之后还有一次 STW 重新扫描栈的整机停顿，混合写屏障就是解决这个问题的。

        混合写屏障扫描栈虽然没有 STW，但是**扫描某一个具体的栈的时候，还是要停止这个 goroutine 赋值器的工作的**（针对一个 goroutine 栈来说，是暂停扫的，要么全灰，要么全黑哈，原子状态切换）；

只暂停一个 goroutine 栈会不会有问题，我钻牛角尖的思考过一些奇怪的场景，比如下面：

**初始状态**：

1. goroutine 1 已经被扫描黑了（由于混合写屏障的场景，赋值器是黑色赋值器，之后不会在扫描了），goroutine 1 上的 A 对象 指向 nil ；
2. B 唯一指向 C（灰色的栈对象 B，白色的 C 对象）；

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/85a5e25c-f27b-47ff-a86b-8320d89778c8/Untitled.png)

**步骤一**：赋值器（g1）把 A 指向 C，赋值器（g2）把 B 指向 nil，删除 B -> C 的引用，由于A，B 都是栈上的对象，所以这里的赋值都不会触发写屏障；

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/6e090626-2cab-47a3-97d1-ca6ca66cfe12/Untitled.png)

这样操作下来，是不是就有问题了？

黑色的 A 指向了白色的 C，并且是唯一指向。由于我们说混合写屏障这里是黑色赋值器，黑色的 goroutine 1 栈是不会再扫描了，那等扫描完了，**C 岂不是被错误回收了 ！！！**

这里不会哈。因为这种情况不会出现，证明如下：

如果要实现如上所述场景，需要满足条件：

goroutine 1 栈上的黑色对象 A 引用白色对象 C 只有三种场景：

1. goroutine 1 持有 goroutine 2 栈上的对象 B ;
2. goroutine 1 对象 C；
- g1 不能直接持有 B，不同栈的对象是无法相互访问的，否则就会溢出到堆上；
- g1 不能直接持有 C，直接持有它就违反了假设，并且如果真是直接持有 C，C 一定是灰色的；

# 目标

篇文章目标是弄明白混合写屏障到底是怎么来的，解决什么问题，插入写屏障，删除写屏障 的特点分别是什么？

首先明白一个前提，**栈上，寄存器对象的赋值（插入，删除）不能 hook** ，这个因为考虑到性能损耗和实现复杂度。（ golang 从来没有在栈上使用写屏障，一直都是在堆上的插入写屏障，个人以为也是这个原因）

写屏障就是在赋值代码中，添加一段 hook 代码，这段 hook 代码就是所谓的屏障代码，由编译器在编译期生成。

        虽然插入写屏障能解决问题，但是 golang 针对栈上对象的赋值却没有捕捉（没有生成写屏障），原因自然是性能损耗和实现复杂度的考虑。这就开了一个例外的口子，有一些黑色的栈对象指向了白色的对象，而回收器却无法感知到。golang 的解决发放是：最后再 STW 重新扫描一把栈。这个自然就会导致整个进程的赋值器卡顿，所以后面 golang 是引用混合写屏障解决这个问题。

## 插入写屏障

1. 如果是纯粹的插入写屏障是满足强三色不变式的（永远不会出现黑色对象指向白色对象）；

2.但是由于栈上对象无写屏障（不 hook），那么导致黑色的栈可能指向白色的堆对象，所以必须假定赋值器（mutator）是灰色赋值器，扫描结束之后，必须 STW 重新扫描栈才能确保不丢对象；

1. STW 重新扫描栈再 goroutine 量大且活跃的场景，延迟不可控，经验值平均 10-100ms；

golang 1.5 之后实现的就是这种类型的插入写屏障。

# **混合写屏障**

golang 1.5 之后已经实现了插入写屏障，但是由于栈对象赋值无法 hook 的原因，导致扫描完之后还有一次 STW 重新扫描栈的整机停顿，混合写屏障就是解决这个问题的。

        混合写屏障扫描栈虽然没有 STW，但是**扫描某一个具体的栈的时候，还是要停止这个 goroutine 赋值器的工作的**（针对一个 goroutine 栈来说，是暂停扫的，要么全灰，要么全黑哈，原子状态切换）；

只暂停一个 goroutine 栈会不会有问题，我钻牛角尖的思考过一些奇怪的场景，比如下面：

**初始状态**：

1. goroutine 1 已经被扫描黑了（由于混合写屏障的场景，赋值器是黑色赋值器，之后不会在扫描了），goroutine 1 上的 A 对象 指向 nil ；
2. B 唯一指向 C（灰色的栈对象 B，白色的 C 对象）；

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/85a5e25c-f27b-47ff-a86b-8320d89778c8/Untitled.png)

**步骤一**：赋值器（g1）把 A 指向 C，赋值器（g2）把 B 指向 nil，删除 B -> C 的引用，由于A，B 都是栈上的对象，所以这里的赋值都不会触发写屏障；

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ada08fdd-90da-493c-905e-db32276cb76c/6e090626-2cab-47a3-97d1-ca6ca66cfe12/Untitled.png)

这样操作下来，是不是就有问题了？

黑色的 A 指向了白色的 C，并且是唯一指向。由于我们说混合写屏障这里是黑色赋值器，黑色的 goroutine 1 栈是不会再扫描了，那等扫描完了，**C 岂不是被错误回收了 ！！！**

这里不会哈。因为这种情况不会出现，证明如下：

如果要实现如上所述场景，需要满足条件：

goroutine 1 栈上的黑色对象 A 引用白色对象 C 只有三种场景：

1. goroutine 1 持有 goroutine 2 栈上的对象 B ;
2. goroutine 1 对象 C；
- g1 不能直接持有 B，不同栈的对象是无法相互访问的，否则就会溢出到堆上；
- g1 不能直接持有 C，直接持有它就违反了假设，并且如果真是直接持有 C，C 一定是灰色的；